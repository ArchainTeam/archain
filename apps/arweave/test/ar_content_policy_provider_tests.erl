-module(ar_content_policy_provider_tests).

-include("src/ar.hrl").
-include_lib("eunit/include/eunit.hrl").

-import(ar_test_node, [start/1, sign_tx/2]).
-import(ar_test_node, [assert_post_tx_to_master/2, wait_until_height/2]).

removes_blacklisted_txs_test() ->
	AR = ?AR(20),
	Key1 = {_, Pub1} = ar_wallet:new(),
	Key2 = {_, Pub2} = ar_wallet:new(),
	Key3 = {_, Pub3} = ar_wallet:new(),
	Addr = ar_wallet:to_address(Pub1),
	ToDelTX1 = sign_tx(Key2, #{data => <<>>}),
	ToDelTX2 = sign_tx(Key3, #{data => <<>>}),
	Data = <<(ar_util:encode(ToDelTX1#tx.id))/binary, "\n", (ar_util:encode(ToDelTX2#tx.id))/binary>>,
	GoodTX = sign_tx(Key1, #{tags => [?CONTENT_POLICY_TYPE], data => Data}),
	[Block] = ar_weave:init([{Addr, AR, <<>>}, {ar_wallet:to_address(Pub2), AR, <<>>}, {ar_wallet:to_address(Pub3), AR, <<>>}]),
	{Master, Block} = start(Block),
	assert_post_tx_to_master(Master, GoodTX),
	assert_post_tx_to_master(Master, ToDelTX1),
	assert_post_tx_to_master(Master, ToDelTX2),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	?assertEqual(ToDelTX1, ar_storage:read_tx(ToDelTX1#tx.id)),
	?assertEqual(ToDelTX2, ar_storage:read_tx(ToDelTX2#tx.id)),
	ar_meta_db:put(content_policy_provider, Addr),
	timer:sleep(100),
	?assertEqual(unavailable, ar_storage:read_tx(ToDelTX1#tx.id)),
	?assertEqual(unavailable, ar_storage:read_tx(ToDelTX2#tx.id)).

ignores_txs_without_tags_test() ->
	AR = ?AR(20),
	Key1 = {_, Pub1} = ar_wallet:new(),
	Key2 = {_, Pub2} = ar_wallet:new(),
	Key3 = {_, Pub3} = ar_wallet:new(),
	Addr = ar_wallet:to_address(Pub3),
	ToDelTX = sign_tx(Key2, #{data => <<>>}),
	Data = ar_util:encode(ToDelTX#tx.id),
	BadTX = sign_tx(Key1, #{tags => [], data => Data}),
	GoodTX = sign_tx(Key3, #{tags => [?CONTENT_POLICY_TYPE], data => Data}),
	[Block] = ar_weave:init([{ar_wallet:to_address(Pub1), AR, <<>>}, {ar_wallet:to_address(Pub2), AR, <<>>}, {Addr, AR, <<>>}]),
	{Master, Block} = start(Block),
	assert_post_tx_to_master(Master, BadTX),
	assert_post_tx_to_master(Master, ToDelTX),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	ar_meta_db:put(content_policy_provider, Addr),
	timer:sleep(100),
	?assertEqual(ToDelTX, ar_storage:read_tx(ToDelTX#tx.id)),
	assert_post_tx_to_master(Master, GoodTX),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	ar_meta_db:put(content_policy_provider, Addr),
	timer:sleep(100),
	?assertEqual(unavailable, ar_storage:read_tx(ToDelTX#tx.id)).

ignores_txs_with_misformatted_data_test() ->
	AR = ?AR(20),
	Key1 = {_, Pub1} = ar_wallet:new(),
	Key2 = {_, Pub2} = ar_wallet:new(),
	Key3 = {_, Pub3} = ar_wallet:new(),
	Addr1 = ar_wallet:to_address(Pub1),
	Addr2 = ar_wallet:to_address(Pub3),
	ToDelTX = sign_tx(Key2, #{data => <<>>}),
	BadTX = sign_tx(Key1, #{tags => [?CONTENT_POLICY_TYPE], data => <<"wrong data">>}),
	GoodTX = sign_tx(Key3, #{tags => [?CONTENT_POLICY_TYPE], data => ar_util:encode(ToDelTX#tx.id)}),
	[Block] = ar_weave:init([{Addr1, AR, <<>>}, {ar_wallet:to_address(Pub2), AR, <<>>}, {Addr2, AR, <<>>}]),
	{Master, Block} = start(Block),
	assert_post_tx_to_master(Master, BadTX),
	assert_post_tx_to_master(Master, ToDelTX),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	ar_meta_db:put(content_policy_provider, Addr1),
	timer:sleep(100),
	?assertEqual(ToDelTX, ar_storage:read_tx(ToDelTX#tx.id)),
	assert_post_tx_to_master(Master, GoodTX),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	ar_meta_db:put(content_policy_provider, Addr2),
	timer:sleep(100),
	?assertEqual(unavailable, ar_storage:read_tx(ToDelTX#tx.id)).

ignores_missing_blacklist_wallet_test() ->
	AR = ?AR(20),
	Key1 = {_, Pub1} = ar_wallet:new(),
	Key2 = {_, Pub2} = ar_wallet:new(),
	Key3 = {_, Pub3} = ar_wallet:new(),
	Addr = ar_wallet:to_address(Pub1),
	ToDelTX1 = sign_tx(Key2, #{data => <<>>}),
	ToDelTX2 = sign_tx(Key3, #{data => <<>>}),
	Data = <<(ar_util:encode(ToDelTX1#tx.id))/binary, "\n", (ar_util:encode(ToDelTX2#tx.id))/binary>>,
	GoodTX = sign_tx(Key1, #{tags => [?CONTENT_POLICY_TYPE], data => Data}),
	[Block] = ar_weave:init([{Addr, AR, <<>>}, {ar_wallet:to_address(Pub2), AR, <<>>}, {ar_wallet:to_address(Pub3), AR, <<>>}]),
	{Master, Block} = start(Block),
	assert_post_tx_to_master(Master, ToDelTX1),
	assert_post_tx_to_master(Master, ToDelTX2),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	ar_meta_db:put(content_policy_provider, <<"non-exist-tx">>),
	timer:sleep(100),
	?assertEqual(ToDelTX1, ar_storage:read_tx(ToDelTX1#tx.id)),
	?assertEqual(ToDelTX2, ar_storage:read_tx(ToDelTX2#tx.id)),
	assert_post_tx_to_master(Master, GoodTX),
	ar_node:mine(Master),
	wait_until_height(Master, 1),
	ar_meta_db:put(content_policy_provider, Addr),
	timer:sleep(100),
	?assertEqual(unavailable, ar_storage:read_tx(ToDelTX1#tx.id)),
	?assertEqual(unavailable, ar_storage:read_tx(ToDelTX2#tx.id)).
